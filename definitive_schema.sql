-- Enable the pgcrypto extension for UUID generation
create extension if not exists "pgcrypto" with schema "public";

-- Create the profiles table
create table if not exists public.profiles (
  id uuid not null primary key,
  role text default 'user'
);

-- Create the auctions table
create table if not exists public.auctions (
  id uuid not null default gen_random_uuid() primary key,
  created_at timestamp with time zone not null default now(),
  auction_id_human text not null unique,
  title text not null,
  description text not null,
  category text not null,
  condition text not null,
  starting_price numeric not null,
  current_bid numeric not null,
  bid_increment numeric not null,
  start_time timestamp with time zone not null,
  end_time timestamp with time zone not null,
  image_urls text[] not null,
  has_buy_now boolean not null default false,
  buy_now_price numeric,
  status text not null default 'Tervezett',
  highest_bidder_id uuid,
  winner_id uuid,
  shipping_address jsonb,
  tracking_number text
);

-- Create the bids table
create table if not exists public.bids (
  id uuid not null default gen_random_uuid() primary key,
  created_at timestamp with time zone not null default now(),
  auction_id uuid not null references public.auctions(id) on delete cascade,
  bidder_id uuid not null references auth.users(id),
  amount numeric not null
);

-- Create the animals table
create table if not exists public.animals (
    id uuid not null default gen_random_uuid() primary key,
    name text not null,
    description text not null,
    gender text not null,
    size text not null,
    age_category text not null,
    images text[],
    status text not null default 'Gazdira vár',
    created_at timestamp with time zone not null default now()
);

-- Create the subscribers table
create table if not exists public.subscribers (
    id bigint generated by default as identity primary key,
    email text not null unique,
    created_at timestamp with time zone not null default now()
);

-- RLS Policies
alter table public.profiles enable row level security;
create policy "Public profiles are viewable by everyone." on public.profiles for select using (true);
create policy "Users can insert their own profile." on public.profiles for insert with check (auth.uid() = id);
create policy "Users can update own profile." on public.profiles for update using (auth.uid() = id);

alter table public.auctions enable row level security;
create policy "Auctions are viewable by everyone." on public.auctions for select using (true);
create policy "Admins can manage auctions." on public.auctions for all using (
  exists (
    select 1 from public.profiles where id = auth.uid() and role = 'admin'
  )
);

alter table public.bids enable row level security;
create policy "Bids are viewable by everyone." on public.bids for select using (true);
create policy "Users can insert their own bids." on public.bids for insert with check (auth.uid() = bidder_id);

alter table public.animals enable row level security;
create policy "Animals are viewable by everyone." on public.animals for select using (true);
create policy "Admins can manage animals." on public.animals for all using (
  exists (
    select 1 from public.profiles where id = auth.uid() and role = 'admin'
  )
);

alter table public.subscribers enable row level security;
create policy "Subscribers can be created by anyone." on public.subscribers for insert with check (true);
create policy "Admins can view subscribers." on public.subscribers for select using (
  exists (
    select 1 from public.profiles where id = auth.uid() and role = 'admin'
  )
);

-- Storage Policies
-- animal-images bucket
-- ... (assuming policies exist)

-- RPC Functions

-- Function to format price
create or replace function format_hungarian_price(price numeric)
returns text as $$
begin
    return to_char(price, 'FM999G999G999') || ' Ft';
end;
$$ language plpgsql;

-- Function to get auction bids with user emails
create or replace function get_auction_bids(p_auction_id uuid)
returns table(id uuid, created_at timestamptz, amount numeric, bidder_email text) as $$
begin
  return query
  select
    b.id,
    b.created_at,
    b.amount,
    u.email as bidder_email
  from
    public.bids b
    join auth.users u on b.bidder_id = u.id
  where
    b.auction_id = p_auction_id
  order by
    b.created_at desc;
end;
$$ language plpgsql security definer;

-- Function to close expired auctions (for cron job)
create or replace function close_expired_auctions()
returns table (
    human_readable_id text,
    item_title text,
    winner_user_id uuid,
    winning_bid_amount numeric
)
language plpgsql
as $$
begin
    -- Update auctions that have ended and are still active
    update auctions
    set status = 'Lejárt'
    where end_time <= now() and status = 'Aktív';

    -- Return details of auctions that just expired and have a winner
    return query
    select
        a.auction_id_human,
        a.title,
        a.highest_bidder_id,
        a.current_bid
    from auctions a
    where a.end_time <= now()
      and a.status = 'Lejárt'
      and a.winner_id is null -- Process only once
      and a.highest_bidder_id is not null;

    -- After returning, update the winner_id to prevent reprocessing
    update auctions a
    set winner_id = a.highest_bidder_id
    where a.end_time <= now()
      and a.status = 'Lejárt'
      and a.winner_id is null
      and a.highest_bidder_id is not null;
end;
$$;

-- Function to place a bid
create or replace function public.place_bid (auction_id_input uuid, bid_amount numeric) returns void as $$
declare
  current_auction record;
  highest_bid numeric;
begin
  -- Get current auction details
  select * into current_auction from public.auctions where id = auction_id_input;

  -- Check if auction exists
  if current_auction is null then
    raise exception 'Az aukció nem található.';
  end if;

  -- Check if auction is active
  if current_auction.status <> 'Aktív' or now() not between current_auction.start_time and current_auction.end_time then
    raise exception 'Az aukció nem aktív vagy már lejárt.';
  end if;

  -- Get the highest bid
  select current_auction.current_bid into highest_bid;

  -- Check if the new bid is high enough
  if bid_amount < (highest_bid + current_auction.bid_increment) then
    -- Allow buy now price even if it's not a valid increment, as long as it's higher
    if not (current_auction.has_buy_now and current_auction.buy_now_price is not null and bid_amount = current_auction.buy_now_price and bid_amount > highest_bid) then
        raise exception 'A licitnek legalább %-kal kell meghaladnia az aktuális legmagasabb licitet.', format_hungarian_price(current_auction.bid_increment);
    end if;
  end if;

  -- Check if the user is outbidding themselves
  if current_auction.highest_bidder_id = auth.uid() then
    raise exception 'Már te adtad a legmagasabb licitet.';
  end if;

  -- Insert the new bid
  insert into public.bids (auction_id, bidder_id, amount)
  values (auction_id_input, auth.uid(), bid_amount);

  -- Check if it's a buy now purchase
  if current_auction.has_buy_now and current_auction.buy_now_price is not null and bid_amount >= current_auction.buy_now_price then
    -- Update auction for buy now: close it immediately
    update public.auctions
    set 
      current_bid = bid_amount,
      highest_bidder_id = auth.uid(),
      winner_id = auth.uid(),
      status = 'Lejárt', -- Close the auction
      end_time = now()      -- Set end time to now
    where id = auction_id_input;
  else
    -- Update auction for a regular bid
    update public.auctions
    set 
      current_bid = bid_amount,
      highest_bidder_id = auth.uid()
    where id = auction_id_input;
  end if;

end;
$$ language plpgsql security definer;